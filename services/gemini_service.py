import os
import json
import google.generativeai as genai

class GeminiService:
    def __init__(self):
        genai.configure(api_key=os.getenv("GEMINI_API_KEY"))
        # For text-only input
        self.model = genai.GenerativeModel('gemini-2.0-flash')

    async def classify_intent_and_extract(self, user_input):
        prompt = (
            "Classifique a inten√ß√£o do usu√°rio a partir do input abaixo. "
            "Se a inten√ß√£o for cota√ß√£o ou swap, extraia tamb√©m os campos fromToken, toToken e fromAmount do input, e responda SOMENTE neste formato JSON:\n"
            '{\"intent\": \"cotacao\", \"fromToken\": \"BTC\", \"toToken\": \"USDC\", \"fromAmount\": \"10\"}\n'
            '{\"intent\": \"swap\", \"fromToken\": \"BTC\", \"toToken\": \"USDC\", \"fromAmount\": \"10\"}\n'
            "IMPORTANTE: \n"
            "- fromToken: √© o token que o usu√°rio QUER TROCAR (o que ele TEM)\n"
            "- toToken: √© o token que o usu√°rio QUER RECEBER\n"
            "- fromAmount: √© a quantidade do fromToken\n"
            "- intent: 'cotacao' para apenas ver pre√ßos, 'swap' para executar a troca\n"
            "\n"
            "Exemplos:\n"
            "- 'quero trocar 1 BTC por USDC' -> intent: 'swap', fromToken: 'BTC', toToken: 'USDC', fromAmount: '1'\n"
            "- 'fazer swap de 1 BTC para USDC' -> intent: 'swap', fromToken: 'BTC', toToken: 'USDC', fromAmount: '1'\n"
            "- 'qual a cota√ß√£o de 1 WBTC em USDC' -> intent: 'cotacao', fromToken: 'WBTC', toToken: 'USDC', fromAmount: '1'\n"
            "- 'quanto vale 1 ETH em USDT' -> intent: 'cotacao', fromToken: 'ETH', toToken: 'USDT', fromAmount: '1'\n"
            "\n"
            "Se n√£o for cota√ß√£o nem swap, responda apenas com a inten√ß√£o (transferencia).\n"
            f"Input: {user_input}"
        )
        
        # Gemini API uses generate_content instead of chat.completions.create
        # The response structure is also different.
        response = await self.model.generate_content_async(prompt)
        
        content = response.text.strip()
        #print("Resposta bruta do Gemini (classify_intent_and_extract):", content)
        try:
            # Attempt to remove markdown and parse JSON
            cleaned_content = content.replace('```json', '').replace('```', '').strip()
            data = json.loads(cleaned_content)
            #print("Dados extra√≠dos:", data) 
            return data
        except Exception as e:
            print(f"Erro ao fazer parse do JSON: {e}. Conte√∫do: {content}")
            # Fallback if JSON parsing fails
            return {"intent": content.lower()}

    async def generate_friendly_message(self, quote_response):
        #print("Quote response recebido:", quote_response)
        prompt = (
            "Receba o seguinte JSON de cota√ß√£o de troca de tokens e gere uma mensagem amig√°vel, clara e objetiva explicando para o usu√°rio o resultado da cota√ß√£o.\n"
            "\n"
            "# Instru√ß√µes obrigat√≥rias:\n"
            "- Informe quanto o usu√°rio vai enviar (valor + s√≠mbolo do token de origem), usando o campo `fromAmount` ajustado pelas casas decimais do token de origem.\n"
            "- Informe quanto o usu√°rio vai receber aproximadamente (valor + s√≠mbolo do token de destino), usando o campo `toAmount` ajustado pelas casas decimais do token de destino.\n"
            "- Use os campos `fromToken` e `toToken` da resposta para identificar os s√≠mbolos corretos dos tokens.\n"
            "- Sempre exiba a taxa estimada de rede, usando o valor em **USD** (campo `amountUSD` dentro de `gasCosts`) e o s√≠mbolo do token que paga a taxa (campo `symbol`, por ex. ETH). Formata√ß√£o esperada:\n"
            "  Taxas estimadas da rede: ~$5,65 em ETH\n"
            "- Informe o tempo estimado de execu√ß√£o em segundos (campo `executionDuration`). Exemplo: Tempo de execu√ß√£o: ~30 segundos\n"
            "- Utilize o padr√£o num√©rico brasileiro: ponto (.) para separar milhares e v√≠rgula (,) para separador decimal (ex.: 1.234,56).\n"
            "- Finalize com a seguinte observa√ß√£o obrigat√≥ria, em it√°lico:\n"
            "  *Lembrando que isso s√£o cota√ß√µes. Quando for fazer a troca, se atente nos valores atualizados e reais da troca.*\n"
            "\n"
            "# Regras:\n"
            "- N√£o afirme que a troca foi realizada. √â apenas uma cota√ß√£o.\n"
            "- N√£o invente dados. Use apenas o que est√° presente no JSON.\n"
            "- N√£o converta valores para outras moedas que n√£o estejam no JSON.\n"
            "- N√£o ofere√ßa conselhos financeiros ou sugest√µes pessoais.\n"
            "- Seja direto, claro e sem floreios.\n"
            "- IMPORTANTE: Use ** para negrito e * para it√°lico, exatamente como mostrado nos exemplos.\n"
            "\n"
            "# Exemplo de estrutura que pode ser usada (n√£o precisa ser id√™ntica sempre, mas mantenha o mesmo tipo de clareza):\n"
            "Com [fromAmount] [fromToken], voc√™ vai receber aproximadamente **[toAmount] [toToken]**.\n"
            "\n"
            "‚õΩ Taxas estimadas da rede: **~$5,65** em ETH\n"
            "üïù Tempo de execu√ß√£o: ~30 segundos\n"
            "\n"
            "*Lembrando que isso s√£o cota√ß√µes. Quando for fazer a troca, se atente nos valores atualizados e reais da troca.*\n"
            "\n"
            f"JSON: {json.dumps(quote_response, ensure_ascii=False)}"
        )

        print("\n\n !!!!!! Prompt enviado ao Gemini (generate_friendly_message):", prompt, "\n\n")
        
        # Gemini API uses generate_content for streaming as well
        # The response structure for streaming chunks is different.
        response_stream = await self.model.generate_content_async(prompt, stream=True)
        
        async for chunk in response_stream:
            if chunk.text: # Check if text is available in the chunk
                yield chunk.text

    async def generate_swap_message(self, swap_response):
        """
        Gera mensagem amig√°vel para swaps, incluindo informa√ß√µes sobre a transa√ß√£o
        """
        prompt = (
            "Receba o seguinte JSON de dados de swap de tokens e gere uma mensagem amig√°vel e clara explicando para o usu√°rio o que acontecer√° na transa√ß√£o.\n"
            "\n"
            "# Instru√ß√µes obrigat√≥rias:\n"
            "- Informe que esta √© uma transa√ß√£o de SWAP (troca), n√£o apenas uma cota√ß√£o\n"
            "- Informe quanto o usu√°rio vai enviar (valor + s√≠mbolo do token de origem), usando o campo `fromAmount` ajustado pelas casas decimais do token de origem.\n"
            "- Informe quanto o usu√°rio vai receber aproximadamente (valor + s√≠mbolo do token de destino), usando o campo `toAmount` ajustado pelas casas decimais do token de destino.\n"
            "- Use os campos `fromToken` e `toToken` da resposta para identificar os s√≠mbolos corretos dos tokens.\n"
            "- Sempre exiba a taxa estimada de rede, usando o valor em **USD** (campo `amountUSD` dentro de `gasCosts`) e o s√≠mbolo do token que paga a taxa (campo `symbol`, por ex. ETH). Formata√ß√£o esperada:\n"
            "  Taxas estimadas da rede: ~$5,65 em ETH\n"
            "- Informe o tempo estimado de execu√ß√£o em segundos (campo `executionDuration`). Exemplo: Tempo de execu√ß√£o: ~30 segundos\n"
            "- Utilize o padr√£o num√©rico brasileiro: ponto (.) para separar milhares e v√≠rgula (,) para separador decimal (ex.: 1.234,56).\n"
            "- Finalize informando que o usu√°rio poder√° revisar e confirmar a transa√ß√£o na pr√≥xima etapa.\n"
            "\n"
            "# Regras:\n"
            "- Deixe claro que esta √© uma transa√ß√£o real de swap, n√£o apenas cota√ß√£o\n"
            "- N√£o invente dados. Use apenas o que est√° presente no JSON.\n"
            "- N√£o converta valores para outras moedas que n√£o estejam no JSON.\n"
            "- Seja direto, claro e sem floreios.\n"
            "- IMPORTANTE: Use ** para negrito e * para it√°lico.\n"
            "\n"
            "# Exemplo de estrutura:\n"
            "üîÑ **Processo de troca entre tokens (Swap) iniciado!**\n"
            "\n"
            "Voc√™ estar√° trocando [fromAmount] [fromToken] por aproximadamente **[toAmount] [toToken]**.\n"
            "\n"
            "‚õΩ Taxas estimadas da rede: **~$5,65** em ETH\n"
            "üïù Tempo de execu√ß√£o: ~30 segundos\n"
            "\n"
            "Na pr√≥xima etapa voc√™ poder√° revisar todos os detalhes e confirmar a transa√ß√£o.\n"
            "\n"
            "Deseja continuar com a transa√ß√£o?"
            f"JSON: {json.dumps(swap_response, ensure_ascii=False)}"
        )

        print("\n\n !!!!!! Prompt enviado ao Gemini (generate_swap_message)", "\n\n")
        
        # Gemini API uses generate_content for streaming as well
        response_stream = await self.model.generate_content_async(prompt, stream=True)
        
        async for chunk in response_stream:
            if chunk.text: # Check if text is available in the chunk
                yield chunk.text
